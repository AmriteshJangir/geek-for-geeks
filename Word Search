Question:
You are given a matrix mat[][] of size n*m containing english alphabets and a string word. Check if the word exists on the mat[][] or not. The word can be constructed by using letters from adjacent cells, either horizontally or vertically. The same cell cannot be used more than once.
Examples:
Input: mat[][] = [['T', 'E', 'E'], ['S', 'G', 'K'], ['T', 'E', 'L']], word = "GEEK"
Output: true
Explanation: Word "GEEK" can be found in the given grid as follows.
Input: mat[][] = [['T', 'E', 'U'], ['S', 'G', 'K'], ['T', 'E', 'L']], word = "GEEK"
Output: false
Explanation: Word "GEEK" cannot be found in the given grid.
Input: mat[][] = [['A', 'B', 'A'], ['B', 'A', 'B']], word = "AB"
Output: true
Explanation: There are multiple ways to construct the word "AB".
Constraints:
1 ≤ n, m ≤ 6
1 ≤ word.size() ≤ 15

Solution:
class Solution {
    int n, m;
    public boolean isWordExist(char[][] mat, String word) {
        n = mat.length;
        m = mat[0].length;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                if(mat[i][j] == word.charAt(0)){
                    if(dfs(mat, word, i, j, 0)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    private boolean dfs(char[][] mat, String word, int i, int j, int idx){
        if(idx == word.length()) return true;
        if(i < 0 || j < 0 || i >= n || j >= m || mat[i][j] != word.charAt(idx)){
            return false;
        }
        char temp = mat[i][j];
        mat[i][j] = '#'; // mark visited
        boolean found = dfs(mat, word, i+1, j, idx+1) ||
                        dfs(mat, word, i-1, j, idx+1) ||
                        dfs(mat, word, i, j+1, idx+1) ||
                        dfs(mat, word, i, j-1, idx+1);
        mat[i][j] = temp; // backtrack
        return found;
    }
}
